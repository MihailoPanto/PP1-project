package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

// - TERMINALI -

terminal PROG, CONST, IF, NEW, PRINT, READ, RETURN, VOID, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL_EQUAL, DIFFERENT, GREATER;
terminal GREATER_EQUAL, LESS, LESS_EQUAL, AND, OR, EQUAL, PLUS_PLUS;
terminal MINUS_MINUS, SEMI, DOUBLE_DOT, COMMA, DOT, LPAREN, RPAREN;
terminal LSBRACE, RSBRACE, LBRACE, RBRACE, TWO_DOUBLE_DOT, ELSE;
terminal String BOOL;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal String CHAR;

// - NETERMINALI -

// program
// consts & var
nonterminal ConstVarDeclList ConstVarDeclList;
nonterminal ConstVarDecl ConstVarDecl;
nonterminal ConstDecl ConstDecl;
nonterminal ConstDeclList ConstDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclList VarDeclList;
nonterminal OptionalSquareBrackets OptionalSquareBrackets;	
// namespace
nonterminal NamespaceList NamespaceList;
// method
nonterminal MethodDeclList MethodDeclList;
nonterminal MethodType MethodType;
nonterminal FormParsOpt FormParsOpt;
nonterminal FormPars FormPars;
nonterminal FormPar FormPar;
nonterminal LocalVarDeclList LocalVarDeclList;
// statement
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal OptPrint OptPrint;
// designator
// operators
nonterminal MulOp MulOp;
nonterminal AddOp AddOp;
nonterminal AssignOp AssignOp;
nonterminal RelOp RelOp;
// conditions
nonterminal ConditionList ConditionList;
nonterminal CondTermList CondTermList;
nonterminal CondFact CondFact;

// symboltable obj
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, Namespace, NamespaceName, MethodDecl, MethodTypeName, NamespaceAccess, Designator, DesignatorStatement;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstDeclaration, VarDeclaration;
// symboltable struct
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, ConstValue, Expr, Term, Factor;


// -------------------- PROGRAM --------------------

Program ::= (Program) PROG ProgName:p NamespaceList:N1 ConstVarDeclList:C2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(p, N1, C2, M3); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

// -------------------- NAMESPACE --------------------

NamespaceList ::= (NameSpacesList) NamespaceList:N1 Namespace:N2 {: RESULT=new NameSpacesList(N1, N2); RESULT.setLine(N1left); :}
		|
		(NoNameSpacesList) {: RESULT=new NoNameSpacesList(); :} /*epsilon*/
		;

Namespace ::= (Namespace) NAMESPACE NamespaceName:n LBRACE ConstVarDeclList:C1 LBRACE RBRACE MethodDeclList:M2 RBRACE {: RESULT=new Namespace(n, C1, M2); RESULT.setLine(nleft); :};

NamespaceName ::= (NamespaceName) IDENT:namespaceName {: RESULT=new NamespaceName(namespaceName); RESULT.setLine(namespaceNameleft); :};

// -------------------- METHOD --------------------

MethodDeclList ::= (MethodDeclarationList) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarationList(M1, M2); RESULT.setLine(M1left); :}
		|
		(NoMethodDeclarationList) {: RESULT=new NoMethodDeclarationList(); :} /*epsilon*/
		;
				
MethodDecl ::= (MethodDecl) MethodTypeName:methodTypeName LPAREN FormParsOpt:F1 RPAREN LocalVarDeclList:L2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(methodTypeName, F1, L2, S3); RESULT.setLine(methodTypeNameleft); :};

MethodTypeName ::= (MethodTypeNameType) Type:methodType IDENT:methodName {: RESULT=new MethodTypeNameType(methodType, methodName); RESULT.setLine(methodTypeleft); :}
		|
		(MethodTypeNameVoid) VOID:methodType IDENT:methodName {: RESULT=new MethodTypeNameVoid(methodName); RESULT.setLine(methodNameleft); :}
		;
			
FormParsOpt ::= (FormParsOptional) FormPars:F1 {: RESULT=new FormParsOptional(F1); RESULT.setLine(F1left); :}
		|
		(NoFormParsOptional) {: RESULT=new NoFormParsOptional(); :}/*epsilon*/
		;
			
FormPars ::= (FPars) FormPars:F1 COMMA FormPar:F2 {: RESULT=new FPars(F1, F2); RESULT.setLine(F1left); :}
		|
		(FPar) FormPar:F1 {: RESULT=new FPar(F1); RESULT.setLine(F1left); :}
		;

FormPar ::= (FormPar) Type:T1 IDENT:I2 OptionalSquareBrackets:O3 {: RESULT=new FormPar(T1, I2, O3); RESULT.setLine(T1left); :};

LocalVarDeclList ::= (LocalVarDeclarationList) LocalVarDeclList:L1 VarDecl:V2 {: RESULT=new LocalVarDeclarationList(L1, V2); RESULT.setLine(L1left); :}
		|
		(NoLocalVarDeclarationList) {: RESULT=new NoLocalVarDeclarationList(); :} /*epsilon*/
		;

// -------------------- CONST VAR --------------------

ConstVarDeclList ::= (ConstVarDeclarationList) ConstVarDeclList:C1 ConstVarDecl:C2 {: RESULT=new ConstVarDeclarationList(C1, C2); RESULT.setLine(C1left); :}
		|
		(NoConstVarDeclarationList) {: RESULT=new NoConstVarDeclarationList(); :} /*epsilon*/
		;

ConstVarDecl ::= (ConstCVDeclaration) ConstDecl:C1 {: RESULT=new ConstCVDeclaration(C1); RESULT.setLine(C1left); :}
		|
		(VarCVDeclaration) VarDecl:V1 {: RESULT=new VarCVDeclaration(V1); RESULT.setLine(V1left); :}
		;
				
				
// -------------------- CONST --------------------
				
ConstDecl ::= (TypeSemiConstDecl) CONST Type:T1 ConstDeclList:C2 SEMI {: RESULT=new TypeSemiConstDecl(T1, C2); RESULT.setLine(T1left); :};

		
ConstDeclList ::= (CommaConstDeclList) ConstDeclList:C1 COMMA ConstDeclaration:C2 {: RESULT=new CommaConstDeclList(C1, C2); RESULT.setLine(C1left); :}
		|
		(SingleConstDecl) ConstDeclaration:C1 {: RESULT=new SingleConstDecl(C1); RESULT.setLine(C1left); :}
		;
				
ConstDeclaration ::= (ConstDeclaration) IDENT:constName EQUAL ConstValue:constValue {: RESULT=new ConstDeclaration(constName, constValue); RESULT.setLine(constNameleft); :};

ConstValue ::= (NumberConst) NUMBER:N1 {: RESULT=new NumberConst(N1); RESULT.setLine(N1left); :}
		|
		(CharConst) CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
		|
		(BoolConst) BOOL:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
		;

// -------------------- VAR --------------------

VarDecl ::= (TypeSemiVarDecl) Type:T1 VarDeclList:V2 SEMI {: RESULT=new TypeSemiVarDecl(T1, V2); RESULT.setLine(T1left); :}
		|
		(ErrorVarDecl) error SEMI:l
		{: parser.report_error("Oporavak izvrsen do ; u liniji " + lleft, null); :} {: RESULT=new ErrorVarDecl(); :}
		;

VarDeclList ::= (CommaVarDeclList) VarDeclList:V1 COMMA VarDeclaration:V2 {: RESULT=new CommaVarDeclList(V1, V2); RESULT.setLine(V1left); :}
		|
		(NoCommaVarDeclList) VarDeclaration:V1 {: RESULT=new NoCommaVarDeclList(V1); RESULT.setLine(V1left); :}
		|
		(ErrorCommaVList) error:l 
		{: parser.report_error("Oporavak izvrsen do , u liniji " + lleft, null); :} {: RESULT=new ErrorCommaVList(); :}
		;
	
VarDeclaration ::= (VArrayDeclaration) IDENT:varName LSBRACE RSBRACE {: RESULT=new VArrayDeclaration(varName); RESULT.setLine(varNameleft); :}
		|
		(VDeclaration) IDENT:varName {: RESULT=new VDeclaration(varName); RESULT.setLine(varNameleft); :}
		;
						
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

// -------------------- STATEMENT --------------------

StatementList ::= (StmtList) StatementList:S1 Statement:S2 {: RESULT=new StmtList(S1, S2); RESULT.setLine(S1left); :}
		|
		(NoStmtList) {: RESULT=new NoStmtList(); :} /*epsilon*/
		;

Statement ::= (StmtDesignatorStatement) DesignatorStatement:D1 SEMI {: RESULT=new StmtDesignatorStatement(D1); RESULT.setLine(D1left); :}
		|
		(StmtError) error SEMI:l 
		{: parser.report_error("Oporavak izvrsen do , u liniji " + lleft, null); :} {: RESULT=new StmtError(); :}
		|
		(StmtRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StmtRead(D1); RESULT.setLine(D1left); :}
		|
		(StmtPrint) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StmtPrint(E1); RESULT.setLine(E1left); :}
		|
		(StmtPrintNum) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new StmtPrintNum(E1, N2); RESULT.setLine(E1left); :}
		;

DesignatorStatement ::= (DesignatorAssign) Designator:D1 AssignOp:A2 Expr:E3 {: RESULT=new DesignatorAssign(D1, A2, E3); RESULT.setLine(D1left); :}
		|
		(DesignatorPlusPlus)Designator:D1 PLUS_PLUS {: RESULT=new DesignatorPlusPlus(D1); RESULT.setLine(D1left); :}
		|
		(DesignatorMinusMinus) Designator:D1 MINUS_MINUS {: RESULT=new DesignatorMinusMinus(D1); RESULT.setLine(D1left); :}
		;

Expr ::= (ExprMinus) MINUS Term:T1 {: RESULT=new ExprMinus(T1); RESULT.setLine(T1left); :}
		|
		(ExprAddop) Expr:E1 AddOp:A2 Term:T3 {: RESULT=new ExprAddop(E1, A2, T3); RESULT.setLine(E1left); :}
		|
		(ExprTerm) Term:T1 {: RESULT=new ExprTerm(T1); RESULT.setLine(T1left); :}
		;

Term ::= (TermMulOp) Term:T1 MulOp:M2 Factor:F3 {: RESULT=new TermMulOp(T1, M2, F3); RESULT.setLine(T1left); :}
		|
		(TermFactor) Factor:F1 {: RESULT=new TermFactor(F1); RESULT.setLine(F1left); :}
		; 

Factor ::= (FactorConstValueNum) NUMBER:N1 {: RESULT=new FactorConstValueNum(N1); RESULT.setLine(N1left); :}
		|
		(FactorConstValueChar) CHAR:C1 {: RESULT=new FactorConstValueChar(C1); RESULT.setLine(C1left); :}
		|
		(FactorConstValueBool) BOOL:B1 {: RESULT=new FactorConstValueBool(B1); RESULT.setLine(B1left); :}
		|
		(FactorNew) NEW Type:T1 LSBRACE Expr:E2 RSBRACE {: RESULT=new FactorNew(T1, E2); RESULT.setLine(T1left); :}
		|
		(FactorExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorExpr(E1); RESULT.setLine(E1left); :}
		|
		(FactorDesignator) Designator:D1 {: RESULT=new FactorDesignator(D1); RESULT.setLine(D1left); :}
		;

Designator ::= (DesignatorIdentBraces) IDENT:desigName LSBRACE Expr:E1 RSBRACE {: RESULT=new DesignatorIdentBraces(desigName, E1); RESULT.setLine(desigNameleft); :}
		|
		(DesignatorNamespaceBraces) IDENT:namespaceName TWO_DOUBLE_DOT IDENT:desigName LSBRACE Expr:E1 RSBRACE {: RESULT=new DesignatorNamespaceBraces(namespaceName, desigName, E1); RESULT.setLine(namespaceNameleft); :}
		|
		(DesignatorNamespace) IDENT:namespaceName TWO_DOUBLE_DOT IDENT:desigName {: RESULT=new DesignatorNamespace(namespaceName, desigName); RESULT.setLine(namespaceNameleft); :}
		|
		(DesignatorIdent) IDENT:desigName {: RESULT=new DesignatorIdent(desigName); RESULT.setLine(desigNameleft); :}
		;
	
// -------------------- CONDITIONS --------------------
			
ConditionList ::= (CondListOr) ConditionList:C1 OR CondTermList:C2 {: RESULT=new CondListOr(C1, C2); RESULT.setLine(C1left); :}
		|
		(CondListNoOr)CondTermList:C1 {: RESULT=new CondListNoOr(C1); RESULT.setLine(C1left); :}
		;
		
CondTermList ::= (CondTermListAnd) CondTermList:C1 AND CondFact:C2 {: RESULT=new CondTermListAnd(C1, C2); RESULT.setLine(C1left); :}
		|
		(CondTermListNoAnd) CondFact:C1 {: RESULT=new CondTermListNoAnd(C1); RESULT.setLine(C1left); :}
		;
		
CondFact ::= (CondFactRelOp) Expr:E1 RelOp:R2 Expr:E3 {: RESULT=new CondFactRelOp(E1, R2, E3); RESULT.setLine(E1left); :}
		|
		(CondFactNoRelOp) Expr:E1 {: RESULT=new CondFactNoRelOp(E1); RESULT.setLine(E1left); :}
		;			

// -------------------- OPERATORS --------------------

RelOp ::= (RelOp_EqualEqual) EQUAL_EQUAL {: RESULT=new RelOp_EqualEqual(); :} 
		|	
		(RelOp_Different) DIFFERENT {: RESULT=new RelOp_Different(); :}
		|	
		(RelOp_Greater) GREATER {: RESULT=new RelOp_Greater(); :}
		|	
		(RelOp_Greater_Equal) GREATER_EQUAL {: RESULT=new RelOp_Greater_Equal(); :}
		|	
		(RelOp_Less) LESS {: RESULT=new RelOp_Less(); :}
		|	
		(RelOp_Less_Equal) LESS_EQUAL {: RESULT=new RelOp_Less_Equal(); :}
		;

AssignOp ::= (AssignOpEqual) EQUAL {: RESULT=new AssignOpEqual(); :};

AddOp ::= (AddOpPlus) PLUS {: RESULT=new AddOpPlus(); :}
		|
		(AddOpMinus) MINUS {: RESULT=new AddOpMinus(); :}
		;
		
MulOp ::= (Mul) MUL {: RESULT=new Mul(); :}
		|
		(Div) DIV {: RESULT=new Div(); :}
		|
		(Mod) MOD {: RESULT=new Mod(); :}
		;